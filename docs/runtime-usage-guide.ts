/**
 * TypeScript Usage Guide for core-runtime WASM
 * 
 * Demonstrates:
 * - Logging configuration
 * - Event bus usage (pub/sub)
 * - Feature flags
 * - Type-safe event handling with AUTO-GENERATED types
 * - Metadata API configuration
 * 
 * NOTE: Event types are now AUTO-GENERATED by tsify from Rust!
 * No more manual type definitions needed.
 * 
 * ‚ö†Ô∏è IMPORTANT: WASM Module Isolation
 * ============================================
 * If you load separate WASM modules (core-runtime.wasm + core-sync.wasm),
 * each has ISOLATED logging configuration!
 * 
 * - setupLogging() in core-runtime does NOT affect core-sync logs
 * - Each WASM file has separate memory and global state
 * - You must initialize logging in EACH module separately
 * 
 * RECOMMENDED: Use monolithic build (mpc-wasm) to avoid this issue.
 * See: docs/WASM_LOGGING_ISOLATION.md for details.
 */

import init, {
  // Logging
  JsLoggingConfig,
  initLogging,
  
  // Event Bus
  JsEventBus,
  JsEventReceiver,
  
  // Configuration
  JsFeatureFlags,
  JsMetadataApiConfig,
  
  // Utilities
  version,
  name,
  getEventType,
  getEventSeverity,
  getEventDescription,
  
  // Enums
  JsEventType,
  JsEventSeverity,
  
  // ‚ú® AUTO-GENERATED TYPES from Rust via tsify!
  // These are automatically in sync with Rust definitions
  type CoreEvent,
  type AuthEvent,
  type SyncEvent,
  type LibraryEvent,
  type PlaybackEvent,
} from '../core-runtime/pkg/core_runtime.js';

// ============================================================================
// Type-Safe Event Handling with Auto-Generated Types
// ============================================================================

/**
 * NOTE: All event types (CoreEvent, AuthEvent, SyncEvent, etc.) are now
 * AUTO-GENERATED by the tsify crate during WASM build!
 * 
 * Benefits:
 * - ‚úÖ Always in sync with Rust
 * - ‚úÖ Zero maintenance
 * - ‚úÖ Single source of truth
 * - ‚úÖ Full IDE autocomplete
 * 
 * The types are generated from Rust enums with #[derive(tsify::Tsify)]
 */

// ============================================================================
// Type-Safe Event Bus Wrapper (Using Auto-Generated Types)
// ============================================================================

/**
 * Type-safe wrapper around JsEventBus that provides:
 * - Type checking for emitted events (using auto-generated CoreEvent type)
 * - Type narrowing for received events
 * - IDE autocompletion
 * 
 * All type safety comes from Rust via tsify - no manual typing needed!
 */
export class TypeSafeEventBus {
  private bus: JsEventBus;

  constructor(capacity: number = 100) {
    this.bus = new JsEventBus(capacity);
  }

  /**
   * Emit a type-safe event
   * TypeScript will validate the event structure at compile time
   */
  emit(event: CoreEvent): number {
    const eventJson = JSON.stringify(event);
    return this.bus.emit(eventJson);
  }

  /**
   * Subscribe and get a type-safe receiver
   */
  subscribe(): TypeSafeEventReceiver {
    return new TypeSafeEventReceiver(this.bus.subscribe());
  }

  /**
   * Get subscriber count
   */
  subscriberCount(): number {
    return this.bus.subscriberCount();
  }

  /**
   * Get raw bus (for passing to Rust functions that need it)
   * Example: new JsSyncService(library, eventBus.getRawBus())
   */
  getRawBus(): JsEventBus {
    return this.bus;
  }
}

/**
 * Type-safe event receiver with auto-generated type support
 */
export class TypeSafeEventReceiver {
  constructor(private receiver: JsEventReceiver) {}

  /**
   * Receive next event with full type safety
   * Returns CoreEvent with all discriminated union variants
   */
  async recv(): Promise<CoreEvent> {
    const eventJson = await this.receiver.recv();
    return JSON.parse(eventJson) as CoreEvent;
  }

  /**
   * Try receive without blocking
   * Returns null if no events available
   */
  tryRecv(): CoreEvent | null {
    const eventJson = this.receiver.tryRecv();
    return eventJson ? (JSON.parse(eventJson) as CoreEvent) : null;
  }

  /**
   * Filter events by type with TypeScript type narrowing
   * Example: recvType('Auth') returns only Auth events
   */
  async recvType<T extends CoreEvent['type']>(
    type: T
  ): Promise<Extract<CoreEvent, { type: T }>> {
    while (true) {
      const event = await this.recv();
      if (event.type === type) {
        return event as Extract<CoreEvent, { type: T }>;
      }
    }
  }

  /**
   * Filter by specific event variant with full type narrowing
   * Example: recvSpecific('Auth', 'SignedIn') returns only SignedIn events
   */
  async recvSpecific<
    T extends CoreEvent['type'],
    E extends Extract<CoreEvent, { type: T }>['payload']['event']
  >(
    type: T,
    eventName: E
  ): Promise<Extract<CoreEvent, { type: T; payload: { event: E } }>> {
    while (true) {
      const event = await this.recv();
      if (event.type === type && event.payload.event === eventName) {
        return event as Extract<
          CoreEvent,
          { type: T; payload: { event: E } }
        >;
      }
    }
  }
}

// ============================================================================
// 1. Initialize WASM
// ============================================================================

async function initializeWasm() {
  await init();
  console.log(`‚úì Initialized ${name()} v${version()}`);
}

// ============================================================================
// 2. Setup Logging
// ============================================================================

function setupLogging() {
  const config = new JsLoggingConfig();
  
  // Set log level (0=Trace, 1=Debug, 2=Info, 3=Warn, 4=Error)
  config.setLevel(1); // Debug level
  
  // Set format (0=Pretty, 1=Json, 2=Compact)
  config.setFormat(0); // Pretty format for development
  
  // Enable PII redaction (true = redact tokens, emails, etc.)
  config.setRedactPii(true);
  
  // Optional: Set custom filter
  // config.setFilter("core_runtime=debug,core_library=trace");
  
  // Enable span contexts for distributed tracing
  config.setSpans(true);
  
  // Display target module in logs
  config.setDisplayTarget(true);
  
  // Initialize logging
  initLogging(config);
  
  console.log('‚úì Logging configured');
  
  // ‚ö†Ô∏è IMPORTANT: If using SEPARATE WASM modules (not recommended)
  // You must call initLogging() in EACH module:
  //
  // import { initLogging as initSyncLogging } from './core-sync.js';
  // const syncConfig = new JsSyncLoggingConfig();
  // syncConfig.setLevel(1);
  // initSyncLogging(syncConfig);
  //
  // This is why MONOLITHIC BUILD is recommended!
}

// ============================================================================
// 3. Type-Safe Event Bus Usage (With Auto-Generated Types!)
// ============================================================================

async function demonstrateTypeSafeEvents() {
  console.log('\n=== Type-Safe Event Bus Demo (Auto-Generated Types) ===\n');
  
  // Create type-safe event bus
  const eventBus = new TypeSafeEventBus(100);
  
  // Subscribe with type safety
  const receiver = eventBus.subscribe();
  
  // Start listening for events
  const listener = (async () => {
    try {
      // Receive any event with full type safety from auto-generated CoreEvent
      const event = await receiver.recv();
      
      // Type narrowing works perfectly with tsify-generated types
      switch (event.type) {
        case 'Auth':
          // TypeScript knows event.payload is AuthEvent (auto-generated)
          console.log(`Auth Event: ${event.payload.event}`);
          if (event.payload.event === 'SignedIn') {
            // IDE autocomplete works because types are from Rust!
            console.log(`  Profile: ${event.payload.profile_id}`);
            console.log(`  Provider: ${event.payload.provider}`);
          }
          break;
          
        case 'Sync':
          console.log(`Sync Event: ${event.payload.event}`);
          if (event.payload.event === 'Progress') {
            // All field types come from Rust enum definition
            console.log(`  Progress: ${event.payload.percent}%`);
            console.log(`  Phase: ${event.payload.phase}`);
            // TypeScript knows total_items is number | null (from Rust Option<u64>)
            console.log(`  Items: ${event.payload.items_processed}${event.payload.total_items ? `/${event.payload.total_items}` : ''}`);
          }
          break;
          
        case 'Library':
          console.log(`Library Event: ${event.payload.event}`);
          if (event.payload.event === 'TrackAdded') {
            console.log(`  Track: ${event.payload.title}`);
            console.log(`  Artist: ${event.payload.artist ?? 'Unknown'}`);
          }
          break;
          
        case 'Playback':
          console.log(`Playback Event: ${event.payload.event}`);
          if (event.payload.event === 'Started') {
            console.log(`  Now Playing: ${event.payload.title}`);
          }
          break;
      }
    } catch (e) {
      console.error('Event receiver error:', e);
    }
  })();
  
  // Emit type-safe events
  // ‚ú® TypeScript validates these against AUTO-GENERATED types!
  // If you make a typo or wrong type, TypeScript will catch it at compile time
  eventBus.emit({
    type: 'Auth',
    payload: {
      event: 'SignedIn',
      profile_id: 'user-123',
      provider: 'GoogleDrive',
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Progress',
      job_id: 'job-456',
      items_processed: 50,
      total_items: 100, // This matches Rust Option<u64>
      percent: 50,
      phase: 'Extracting metadata',
    },
  });
  
  eventBus.emit({
    type: 'Library',
    payload: {
      event: 'TrackAdded',
      track_id: 'track-789',
      title: 'Bohemian Rhapsody',
      artist: 'Queen', // Option<String> in Rust = string | null in TS
      album: 'A Night at the Opera',
    },
  });
  
  // Wait for events to process
  await new Promise(resolve => setTimeout(resolve, 100));
  
  console.log('\n‚úì Type-safe events demonstrated with auto-generated types');
}

// ============================================================================
// 4. Passing Objects Back to Rust (Recommended Pattern)
// ============================================================================

/**
 * Best Practice: Direct parameter passing
 * 
 * wasm-bindgen handles object passing automatically!
 * Just pass JS objects as parameters to Rust functions.
 * 
 * Example Rust side:
 * ```rust
 * #[wasm_bindgen]
 * impl JsSyncService {
 *     #[wasm_bindgen(constructor)]
 *     pub fn new(library: JsLibrary, event_bus: JsEventBus) -> Self {
 *         Self { library, event_bus }
 *     }
 * }
 * ```
 * 
 * No serialization, no global state needed!
 */

async function demonstratePassingToRust() {
  console.log('\n=== Passing Objects to Rust Demo ===\n');
  
  // Create event bus in JS
  const eventBus = new TypeSafeEventBus(100);
  
  // ‚úÖ Recommended: Pass directly as parameter
  // Example (when JsSyncService is available):
  // const syncService = new JsSyncService(library, eventBus.getRawBus());
  
  console.log('‚úì Event bus created and ready to pass to Rust');
  console.log('  Usage: new JsSyncService(library, eventBus.getRawBus())');
  
  // The raw JsEventBus can be passed to any Rust function that accepts it
  const rawBus = eventBus.getRawBus();
  console.log('‚úì Raw bus reference obtained:', rawBus);
  
  // Rust will maintain a reference to this object
  // It works automatically thanks to wasm-bindgen!
}

// ============================================================================
// 5. Feature Flags Configuration
// ============================================================================

function demonstrateFeatureFlags() {
  console.log('\n=== Feature Flags Demo ===\n');
  
  const flags = new JsFeatureFlags();
  
  // Enable features
  flags.setEnableLyrics(true);
  flags.setEnableArtworkRemote(true);
  flags.setEnableOfflineCache(false);
  flags.setEnableBackgroundSync(true);
  flags.setEnableNetworkAwareness(false);
  
  // Get as JSON for storage/transmission
  const flagsJson = flags.toJson();
  console.log('Feature Flags:', flagsJson);
  
  console.log('‚úì Feature flags configured');
}

// ============================================================================
// 6. Metadata API Configuration
// ============================================================================

function demonstrateMetadataConfig() {
  console.log('\n=== Metadata API Config Demo ===\n');
  
  const config = new JsMetadataApiConfig();
  
  // Set MusicBrainz user agent (required format)
  config.setMusicBrainzUserAgent('MyMusicApp/1.0 (contact@example.com)');
  
  // Set Last.fm API key
  config.setLastfmApiKey('your_lastfm_api_key_here');
  
  // Set rate limit (milliseconds between requests - note: Rust u64 = bigint)
  config.setRateLimitDelayMs(BigInt(1000)); // 1 request per second
  
  // Validate configuration
  try {
    config.validate();
    console.log('‚úì Metadata API config valid');
  } catch (e) {
    console.error('Config validation failed:', e);
  }
  
  // Check what's configured
  console.log('MusicBrainz configured:', config.hasMusicBrainz());
  console.log('Last.fm configured:', config.hasLastfm());
  
  const configJson = config.toJson();
  console.log('Config:', configJson);
}

// ============================================================================
// 7. Event Filtering with Type Safety (Auto-Generated Types)
// ============================================================================

async function demonstrateEventFiltering() {
  console.log('\n=== Event Filtering Demo (With Auto-Generated Types) ===\n');
  
  const eventBus = new TypeSafeEventBus(100);
  const receiver = eventBus.subscribe();
  
  // Listen only for Auth events
  // Type narrowing works perfectly with tsify-generated discriminated unions
  const authListener = (async () => {
    try {
      // This returns typed Auth events only (type is Extract<CoreEvent, { type: 'Auth' }>)
      const authEvent = await receiver.recvType('Auth');
      console.log('Received Auth event:', authEvent.payload.event);
      // TypeScript knows authEvent.payload is AuthEvent
    } catch (e) {
      console.log('Auth listener completed');
    }
  })();
  
  // Emit some events (all validated by auto-generated types)
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Started',
      job_id: 'job-1',
      profile_id: 'user-123',
      provider: 'GoogleDrive',
      is_full_sync: true,
    },
  });
  
  eventBus.emit({
    type: 'Auth',
    payload: {
      event: 'SignedIn',
      profile_id: 'user-123',
      provider: 'GoogleDrive',
    },
  });
  
  await new Promise(resolve => setTimeout(resolve, 100));
  console.log('‚úì Event filtering demonstrated with perfect type safety');
}

// ============================================================================
// 8. Complete Example: Music App Initialization (Production-Ready)
// ============================================================================

async function completeExample() {
  console.log('\n=== Complete Music App Example (With Auto-Generated Types) ===\n');
  
  // 1. Initialize WASM
  await initializeWasm();
  console.log('‚úì WASM initialized');
  
  // 2. Setup logging
  setupLogging();
  console.log('‚úì Logging configured');
  
  // 3. Create type-safe event bus with auto-generated types
  const eventBus = new TypeSafeEventBus(100);
  console.log('‚úì Event bus created (type-safe with tsify)');
  
  // 4. Configure features
  const features = new JsFeatureFlags();
  features.setEnableLyrics(true);
  features.setEnableArtworkRemote(true);
  features.setEnableOfflineCache(false);
  console.log('‚úì Features configured:', features.toJson());
  
  // 5. Configure metadata APIs
  const metadataConfig = new JsMetadataApiConfig();
  metadataConfig.setMusicBrainzUserAgent('MusicApp/1.0 (dev@example.com)');
  metadataConfig.setRateLimitDelayMs(BigInt(1000)); // Rust u64 = TypeScript bigint
  try {
    metadataConfig.validate();
    console.log('‚úì Metadata API config validated');
  } catch (e) {
    console.warn('‚ö† Metadata config validation failed:', e);
  }
  
  // 6. Subscribe to events
  const receiver = eventBus.subscribe();
  console.log('‚úì Subscribed to event bus');
  
  // 7. Start event listener with proper error handling
  const eventLoop = (async () => {
    console.log('üì° Event listener started...');
    let processedEvents = 0;
    
    while (processedEvents < 10) { // Process first 10 events for demo
      try {
        const event = await receiver.recv();
        processedEvents++;
        
        // Handle events with perfect type safety from auto-generated types
        switch (event.type) {
          case 'Auth':
            if (event.payload.event === 'SignedIn') {
              console.log(`‚úì User signed in: ${event.payload.profile_id} via ${event.payload.provider}`);
            } else if (event.payload.event === 'TokenRefreshed') {
              console.log(`üîÑ Token refreshed for: ${event.payload.profile_id}`);
            }
            break;
            
          case 'Sync':
            if (event.payload.event === 'Completed') {
              console.log(`‚úì Sync completed: +${event.payload.items_added} items, ~${event.payload.items_updated} updated`);
            } else if (event.payload.event === 'Progress') {
              console.log(`‚è≥ Sync progress: ${event.payload.percent}% (${event.payload.phase})`);
            }
            break;
            
          case 'Library':
            if (event.payload.event === 'TrackAdded') {
              const artist = event.payload.artist ?? 'Unknown Artist';
              console.log(`‚ô™ Track added: ${event.payload.title} by ${artist}`);
            } else if (event.payload.event === 'PlaylistCreated') {
              console.log(`üìù Playlist created: ${event.payload.name}`);
            }
            break;
            
          case 'Playback':
            if (event.payload.event === 'Started') {
              console.log(`‚ñ∂ Now playing: ${event.payload.title}`);
            } else if (event.payload.event === 'Paused') {
              const positionSec = Math.round(event.payload.position_ms / 1000);
              console.log(`‚è∏ Paused at ${positionSec}s`);
            }
            break;
        }
      } catch (e) {
        console.error('Event loop error:', e);
        break;
      }
    }
    
    console.log(`üìä Processed ${processedEvents} events`);
  })();
  
  // 8. Emit test events (all type-checked by auto-generated types!)
  console.log('\nüì§ Emitting test events...');
  
  eventBus.emit({
    type: 'Auth',
    payload: {
      event: 'SignedIn',
      profile_id: 'demo-user-123',
      provider: 'GoogleDrive',
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Started',
      job_id: 'sync-job-001',
      profile_id: 'demo-user-123',
      provider: 'GoogleDrive',
      is_full_sync: true,
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Progress',
      job_id: 'sync-job-001',
      items_processed: 150,
      total_items: 300,
      percent: 50,
      phase: 'Extracting metadata',
    },
  });
  
  eventBus.emit({
    type: 'Library',
    payload: {
      event: 'TrackAdded',
      track_id: 'track-001',
      title: 'Bohemian Rhapsody',
      artist: 'Queen',
      album: 'A Night at the Opera',
    },
  });
  
  eventBus.emit({
    type: 'Playback',
    payload: {
      event: 'Started',
      track_id: 'track-001',
      title: 'Bohemian Rhapsody',
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Completed',
      job_id: 'sync-job-001',
      items_processed: 300,
      items_added: 285,
      items_updated: 15,
      items_deleted: 0,
      duration_secs: 45,
    },
  });
  
  // Wait for events to process
  await new Promise(resolve => setTimeout(resolve, 200));
  
  console.log('\n‚úÖ Complete example finished');
  console.log('   All events were type-checked using auto-generated types from Rust!');
}

// ============================================================================
// Run All Examples
// ============================================================================

async function main() {
  try {
    await initializeWasm();
    setupLogging();
    await demonstrateTypeSafeEvents();
    await demonstratePassingToRust();
    demonstrateFeatureFlags();
    demonstrateMetadataConfig();
    await demonstrateEventFiltering();
    await completeExample();
    
    console.log('\nüéâ All examples completed successfully!');
  } catch (e) {
    console.error('Error:', e);
  }
}

// Run if this is the main module
if (typeof window !== 'undefined') {
  main();
}

// ============================================================================
// Exports (for use in other modules)
// ============================================================================

// Note: Classes are already exported at declaration, just re-export for clarity
// export { TypeSafeEventBus, TypeSafeEventReceiver };
