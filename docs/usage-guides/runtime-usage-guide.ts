/**
 * TypeScript Usage Guide for core-runtime WASM
 * 
 * Demonstrates:
 * - Logging configuration
 * - Event bus usage (pub/sub)
 * - Feature flags
 * - Type-safe event handling with AUTO-GENERATED types
 * - Metadata API configuration
 * 
 * NOTE: Event types are now AUTO-GENERATED by tsify from Rust!
 * No more manual type definitions needed.
 * 
 * âš ï¸ IMPORTANT: WASM Module Isolation
 * ============================================
 * If you load separate WASM modules (core-runtime.wasm + core-sync.wasm),
 * each has ISOLATED logging configuration!
 * 
 * - setupLogging() in core-runtime does NOT affect core-sync logs
 * - Each WASM file has separate memory and global state
 * - You must initialize logging in EACH module separately
 * 
 * RECOMMENDED: Use monolithic build (mpc-wasm) to avoid this issue.
 * See: docs/WASM_LOGGING_ISOLATION.md for details.
 */

import init, {
  // Logging
  JsLoggingConfig,
  initLogging,
  
  // Event Bus
  JsEventBus,
  JsEventReceiver,
  
  // Configuration
  JsFeatureFlags,
  JsMetadataApiConfig,
  
  // Utilities
  version,
  name,
  getEventType,
  getEventSeverity,
  getEventDescription,
  
  // Event Constructors (Helper functions)
  createAuthSignedInEvent,
  createSyncStartedEvent,
  createSyncProgressEvent,
  createLibraryTrackAddedEvent,
  createPlaybackStartedEvent,
  
  // Enums
  JsEventType,
  JsEventSeverity,
  
  // âœ¨ AUTO-GENERATED TYPES from Rust via tsify!
  // These are automatically in sync with Rust definitions
  type CoreEvent,
  type AuthEvent,
  type SyncEvent,
  type LibraryEvent,
  type PlaybackEvent,
} from '../../core-runtime/pkg/core_runtime.js';

// ============================================================================
// Type-Safe Event Handling with Auto-Generated Types
// ============================================================================

/**
 * NOTE: All event types (CoreEvent, AuthEvent, SyncEvent, etc.) are now
 * AUTO-GENERATED by the tsify crate during WASM build!
 * 
 * Benefits:
 * - âœ… Always in sync with Rust
 * - âœ… Zero maintenance
 * - âœ… Single source of truth
 * - âœ… Full IDE autocomplete
 * 
 * The types are generated from Rust enums with #[derive(tsify::Tsify)]
 */

// ============================================================================
// Type-Safe Event Bus Wrapper (Using Auto-Generated Types)
// ============================================================================

/**
 * Type-safe wrapper around JsEventBus that provides:
 * - Type checking for emitted events (using auto-generated CoreEvent type)
 * - Type narrowing for received events
 * - IDE autocompletion
 * 
 * All type safety comes from Rust via tsify - no manual typing needed!
 */
export class TypeSafeEventBus {
  private bus: JsEventBus;

  constructor(capacity: number = 100) {
    this.bus = new JsEventBus(capacity);
  }

  /**
   * Emit a type-safe event
   * TypeScript will validate the event structure at compile time
   */
  emit(event: CoreEvent): number {
    const eventJson = JSON.stringify(event);
    return this.bus.emit(eventJson);
  }

  /**
   * Subscribe and get a type-safe receiver
   */
  subscribe(): TypeSafeEventReceiver {
    return new TypeSafeEventReceiver(this.bus.subscribe());
  }

  /**
   * Get subscriber count
   */
  subscriberCount(): number {
    return this.bus.subscriberCount();
  }

  /**
   * Get raw bus (for passing to Rust functions that need it)
   * Example: new JsSyncService(library, eventBus.getRawBus())
   */
  getRawBus(): JsEventBus {
    return this.bus;
  }
}

/**
 * Type-safe event receiver with auto-generated type support
 */
export class TypeSafeEventReceiver {
  constructor(private receiver: JsEventReceiver) {}

  /**
   * Receive next event with full type safety
   * Returns CoreEvent with all discriminated union variants
   */
  async recv(): Promise<CoreEvent> {
    const eventJson = await this.receiver.recv();
    return JSON.parse(eventJson) as CoreEvent;
  }

  /**
   * Try receive without blocking
   * Returns null if no events available
   */
  tryRecv(): CoreEvent | null {
    const eventJson = this.receiver.tryRecv();
    return eventJson ? (JSON.parse(eventJson) as CoreEvent) : null;
  }

  /**
   * Filter events by type with TypeScript type narrowing
   * Example: recvType('Auth') returns only Auth events
   */
  async recvType<T extends CoreEvent['type']>(
    type: T
  ): Promise<Extract<CoreEvent, { type: T }>> {
    while (true) {
      const event = await this.recv();
      if (event.type === type) {
        return event as Extract<CoreEvent, { type: T }>;
      }
    }
  }

  /**
   * Filter by specific event variant with full type narrowing
   * Example: recvSpecific('Auth', 'SignedIn') returns only SignedIn events
   */
  async recvSpecific<
    T extends CoreEvent['type'],
    E extends Extract<CoreEvent, { type: T }>['payload']['event']
  >(
    type: T,
    eventName: E
  ): Promise<Extract<CoreEvent, { type: T; payload: { event: E } }>> {
    while (true) {
      const event = await this.recv();
      if (event.type === type && event.payload.event === eventName) {
        return event as Extract<
          CoreEvent,
          { type: T; payload: { event: E } }
        >;
      }
    }
  }
}

// ============================================================================
// 1. Initialize WASM
// ============================================================================

async function initializeWasm() {
  await init();
  console.log(`âœ“ Initialized ${name()} v${version()}`);
}

// ============================================================================
// 2. Setup Logging
// ============================================================================

function setupLogging() {
  const config = new JsLoggingConfig();
  
  // Set log level (0=Trace, 1=Debug, 2=Info, 3=Warn, 4=Error)
  config.setLevel(1); // Debug level
  
  // Set format (0=Pretty, 1=Json, 2=Compact)
  config.setFormat(0); // Pretty format for development
  
  // Enable PII redaction (true = redact tokens, emails, etc.)
  config.setRedactPii(true);
  
  // Optional: Set custom filter
  // config.setFilter("core_runtime=debug,core_library=trace");
  
  // Enable span contexts for distributed tracing
  config.setSpans(true);
  
  // Display target module in logs
  config.setDisplayTarget(true);
  
  // Initialize logging
  initLogging(config);
  
  console.log('âœ“ Logging configured');
  
  // âš ï¸ IMPORTANT: If using SEPARATE WASM modules (not recommended)
  // You must call initLogging() in EACH module:
  //
  // import { initLogging as initSyncLogging } from './core-sync.js';
  // const syncConfig = new JsSyncLoggingConfig();
  // syncConfig.setLevel(1);
  // initSyncLogging(syncConfig);
  //
  // This is why MONOLITHIC BUILD is recommended!
}

// ============================================================================
// 3. Type-Safe Event Bus Usage (With Auto-Generated Types!)
// ============================================================================

async function demonstrateTypeSafeEvents() {
  console.log('\n=== Type-Safe Event Bus Demo (Auto-Generated Types) ===\n');
  
  // Create type-safe event bus
  const eventBus = new TypeSafeEventBus(100);
  
  // Subscribe with type safety
  const receiver = eventBus.subscribe();
  
  // Start listening for events
  const listener = (async () => {
    try {
      // Receive any event with full type safety from auto-generated CoreEvent
      const event = await receiver.recv();
      
      // Type narrowing works perfectly with tsify-generated types
      switch (event.type) {
        case 'Auth':
          // TypeScript knows event.payload is AuthEvent (auto-generated)
          console.log(`Auth Event: ${event.payload.event}`);
          if (event.payload.event === 'SignedIn') {
            // IDE autocomplete works because types are from Rust!
            console.log(`  Profile: ${event.payload.profile_id}`);
            console.log(`  Provider: ${event.payload.provider}`);
          }
          break;
          
        case 'Sync':
          console.log(`Sync Event: ${event.payload.event}`);
          if (event.payload.event === 'Progress') {
            // All field types come from Rust enum definition
            console.log(`  Progress: ${event.payload.percent}%`);
            console.log(`  Phase: ${event.payload.phase}`);
            // TypeScript knows total_items is number | null (from Rust Option<u64>)
            console.log(`  Items: ${event.payload.items_processed}${event.payload.total_items ? `/${event.payload.total_items}` : ''}`);
          }
          break;
          
        case 'Library':
          console.log(`Library Event: ${event.payload.event}`);
          if (event.payload.event === 'TrackAdded') {
            console.log(`  Track: ${event.payload.title}`);
            console.log(`  Artist: ${event.payload.artist ?? 'Unknown'}`);
          }
          break;
          
        case 'Playback':
          console.log(`Playback Event: ${event.payload.event}`);
          if (event.payload.event === 'Started') {
            console.log(`  Now Playing: ${event.payload.title}`);
          }
          break;
      }
    } catch (e) {
      console.error('Event receiver error:', e);
    }
  })();
  
  // Emit type-safe events
  // âœ¨ TypeScript validates these against AUTO-GENERATED types!
  // If you make a typo or wrong type, TypeScript will catch it at compile time
  eventBus.emit({
    type: 'Auth',
    payload: {
      event: 'SignedIn',
      profile_id: 'user-123',
      provider: 'GoogleDrive',
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Progress',
      job_id: 'job-456',
      items_processed: 50,
      total_items: 100, // This matches Rust Option<u64>
      percent: 50,
      phase: 'Extracting metadata',
    },
  });
  
  eventBus.emit({
    type: 'Library',
    payload: {
      event: 'TrackAdded',
      track_id: 'track-789',
      title: 'Bohemian Rhapsody',
      artist: 'Queen', // Option<String> in Rust = string | null in TS
      album: 'A Night at the Opera',
    },
  });
  
  // Wait for events to process
  await new Promise(resolve => setTimeout(resolve, 100));
  
  console.log('\nâœ“ Type-safe events demonstrated with auto-generated types');
}

// ============================================================================
// 4. Passing Objects Back to Rust (Recommended Pattern)
// ============================================================================

/**
 * Best Practice: Direct parameter passing
 * 
 * wasm-bindgen handles object passing automatically!
 * Just pass JS objects as parameters to Rust functions.
 * 
 * Example Rust side:
 * ```rust
 * #[wasm_bindgen]
 * impl JsSyncService {
 *     #[wasm_bindgen(constructor)]
 *     pub fn new(library: JsLibrary, event_bus: JsEventBus) -> Self {
 *         Self { library, event_bus }
 *     }
 * }
 * ```
 * 
 * No serialization, no global state needed!
 */

async function demonstratePassingToRust() {
  console.log('\n=== Passing Objects to Rust Demo ===\n');
  
  // Create event bus in JS
  const eventBus = new TypeSafeEventBus(100);
  
  // âœ… Recommended: Pass directly as parameter
  // Example (when JsSyncService is available):
  // const syncService = new JsSyncService(library, eventBus.getRawBus());
  
  console.log('âœ“ Event bus created and ready to pass to Rust');
  console.log('  Usage: new JsSyncService(library, eventBus.getRawBus())');
  
  // The raw JsEventBus can be passed to any Rust function that accepts it
  const rawBus = eventBus.getRawBus();
  console.log('âœ“ Raw bus reference obtained:', rawBus);
  
  // Rust will maintain a reference to this object
  // It works automatically thanks to wasm-bindgen!
}

// ============================================================================
// 5. Feature Flags Configuration
// ============================================================================

function demonstrateFeatureFlags() {
  console.log('\n=== Feature Flags Demo ===\n');
  
  const flags = new JsFeatureFlags();
  
  // Enable features
  flags.setEnableLyrics(true);
  flags.setEnableArtworkRemote(true);
  flags.setEnableOfflineCache(false);
  flags.setEnableBackgroundSync(true);
  flags.setEnableNetworkAwareness(false);
  
  // Get as JSON for storage/transmission
  const flagsJson = flags.toJson();
  console.log('Feature Flags:', flagsJson);
  
  console.log('âœ“ Feature flags configured');
}

// ============================================================================
// 6. Metadata API Configuration
// ============================================================================

function demonstrateMetadataConfig() {
  console.log('\n=== Metadata API Config Demo ===\n');
  
  const config = new JsMetadataApiConfig();
  
  // Set MusicBrainz user agent (required format)
  config.setMusicBrainzUserAgent('MyMusicApp/1.0 (contact@example.com)');
  
  // Set Last.fm API key
  config.setLastfmApiKey('your_lastfm_api_key_here');
  
  // Set rate limit (milliseconds between requests - note: Rust u64 = bigint)
  config.setRateLimitDelayMs(BigInt(1000)); // 1 request per second
  
  // Validate configuration
  try {
    config.validate();
    console.log('âœ“ Metadata API config valid');
  } catch (e) {
    console.error('Config validation failed:', e);
  }
  
  // Check what's configured
  console.log('MusicBrainz configured:', config.hasMusicBrainz());
  console.log('Last.fm configured:', config.hasLastfm());
  
  const configJson = config.toJson();
  console.log('Config:', configJson);
}

// ============================================================================
// 7. Event Filtering with Type Safety (Auto-Generated Types)
// ============================================================================

async function demonstrateEventFiltering() {
  console.log('\n=== Event Filtering Demo (With Auto-Generated Types) ===\n');
  
  const eventBus = new TypeSafeEventBus(100);
  const receiver = eventBus.subscribe();
  
  // Listen only for Auth events
  // Type narrowing works perfectly with tsify-generated discriminated unions
  const authListener = (async () => {
    try {
      // This returns typed Auth events only (type is Extract<CoreEvent, { type: 'Auth' }>)
      const authEvent = await receiver.recvType('Auth');
      console.log('Received Auth event:', authEvent.payload.event);
      // TypeScript knows authEvent.payload is AuthEvent
    } catch (e) {
      console.log('Auth listener completed');
    }
  })();
  
  // Emit some events (all validated by auto-generated types)
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Started',
      job_id: 'job-1',
      profile_id: 'user-123',
      provider: 'GoogleDrive',
      is_full_sync: true,
    },
  });
  
  eventBus.emit({
    type: 'Auth',
    payload: {
      event: 'SignedIn',
      profile_id: 'user-123',
      provider: 'GoogleDrive',
    },
  });
  
  await new Promise(resolve => setTimeout(resolve, 100));
  console.log('âœ“ Event filtering demonstrated with perfect type safety');
}

// ============================================================================
// 8. Complete Example: Music App Initialization (Production-Ready)
// ============================================================================

async function completeExample() {
  console.log('\n=== Complete Music App Example (With Auto-Generated Types) ===\n');
  
  // 1. Initialize WASM
  await initializeWasm();
  console.log('âœ“ WASM initialized');
  
  // 2. Setup logging
  setupLogging();
  console.log('âœ“ Logging configured');
  
  // 3. Create type-safe event bus with auto-generated types
  const eventBus = new TypeSafeEventBus(100);
  console.log('âœ“ Event bus created (type-safe with tsify)');
  
  // 4. Configure features
  const features = new JsFeatureFlags();
  features.setEnableLyrics(true);
  features.setEnableArtworkRemote(true);
  features.setEnableOfflineCache(false);
  console.log('âœ“ Features configured:', features.toJson());
  
  // 5. Configure metadata APIs
  const metadataConfig = new JsMetadataApiConfig();
  metadataConfig.setMusicBrainzUserAgent('MusicApp/1.0 (dev@example.com)');
  metadataConfig.setRateLimitDelayMs(BigInt(1000)); // Rust u64 = TypeScript bigint
  try {
    metadataConfig.validate();
    console.log('âœ“ Metadata API config validated');
  } catch (e) {
    console.warn('âš  Metadata config validation failed:', e);
  }
  
  // 6. Subscribe to events
  const receiver = eventBus.subscribe();
  console.log('âœ“ Subscribed to event bus');
  
  // 7. Start event listener with proper error handling
  const eventLoop = (async () => {
    console.log('ğŸ“¡ Event listener started...');
    let processedEvents = 0;
    
    while (processedEvents < 10) { // Process first 10 events for demo
      try {
        const event = await receiver.recv();
        processedEvents++;
        
        // Handle events with perfect type safety from auto-generated types
        switch (event.type) {
          case 'Auth':
            if (event.payload.event === 'SignedIn') {
              console.log(`âœ“ User signed in: ${event.payload.profile_id} via ${event.payload.provider}`);
            } else if (event.payload.event === 'TokenRefreshed') {
              console.log(`ğŸ”„ Token refreshed for: ${event.payload.profile_id}`);
            }
            break;
            
          case 'Sync':
            if (event.payload.event === 'Completed') {
              console.log(`âœ“ Sync completed: +${event.payload.items_added} items, ~${event.payload.items_updated} updated`);
            } else if (event.payload.event === 'Progress') {
              console.log(`â³ Sync progress: ${event.payload.percent}% (${event.payload.phase})`);
            }
            break;
            
          case 'Library':
            if (event.payload.event === 'TrackAdded') {
              const artist = event.payload.artist ?? 'Unknown Artist';
              console.log(`â™ª Track added: ${event.payload.title} by ${artist}`);
            } else if (event.payload.event === 'PlaylistCreated') {
              console.log(`ğŸ“ Playlist created: ${event.payload.name}`);
            }
            break;
            
          case 'Playback':
            if (event.payload.event === 'Started') {
              console.log(`â–¶ Now playing: ${event.payload.title}`);
            } else if (event.payload.event === 'Paused') {
              const positionSec = Math.round(event.payload.position_ms / 1000);
              console.log(`â¸ Paused at ${positionSec}s`);
            }
            break;
        }
      } catch (e) {
        console.error('Event loop error:', e);
        break;
      }
    }
    
    console.log(`ğŸ“Š Processed ${processedEvents} events`);
  })();
  
  // 8. Emit test events (all type-checked by auto-generated types!)
  console.log('\nğŸ“¤ Emitting test events...');
  
  eventBus.emit({
    type: 'Auth',
    payload: {
      event: 'SignedIn',
      profile_id: 'demo-user-123',
      provider: 'GoogleDrive',
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Started',
      job_id: 'sync-job-001',
      profile_id: 'demo-user-123',
      provider: 'GoogleDrive',
      is_full_sync: true,
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Progress',
      job_id: 'sync-job-001',
      items_processed: 150,
      total_items: 300,
      percent: 50,
      phase: 'Extracting metadata',
    },
  });
  
  eventBus.emit({
    type: 'Library',
    payload: {
      event: 'TrackAdded',
      track_id: 'track-001',
      title: 'Bohemian Rhapsody',
      artist: 'Queen',
      album: 'A Night at the Opera',
    },
  });
  
  eventBus.emit({
    type: 'Playback',
    payload: {
      event: 'Started',
      track_id: 'track-001',
      title: 'Bohemian Rhapsody',
    },
  });
  
  eventBus.emit({
    type: 'Sync',
    payload: {
      event: 'Completed',
      job_id: 'sync-job-001',
      items_processed: 300,
      items_added: 285,
      items_updated: 15,
      items_deleted: 0,
      duration_secs: 45,
    },
  });
  
  // Wait for events to process
  await new Promise(resolve => setTimeout(resolve, 200));
  
  console.log('\nâœ… Complete example finished');
  console.log('   All events were type-checked using auto-generated types from Rust!');
}

// ============================================================================
// ONE EventBus for ALL Services - Real-World Architecture
// ============================================================================

/**
 * Demonstrates the recommended pattern: ONE EventBus shared by ALL modules.
 * 
 * Key points:
 * - Single EventBus instance created once
 * - All services (auth, sync, playback, etc.) receive the SAME bus
 * - Multiple subscribers can listen independently
 * - Events from ANY service are broadcast to ALL subscribers
 * - Cross-module coordination without tight coupling
 */
async function demonstrateSharedEventBus() {
  console.log('\n=== ONE EventBus for ALL Services ===\n');
  
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STEP 1: Create ONE EventBus (capacity = 100 events)
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  const eventBus = new JsEventBus(100);
  console.log('âœ“ Created EventBus (capacity: 100)');
  
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STEP 2: Pass SAME bus to ALL services
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  
  // Note: These services are imported from other modules (not shown in this file)
  // import { JsAuthManager } from './core_auth';
  // import { JsSyncService } from './core_sync';
  // import { JsPlaybackEngine } from './core_playback';
  
  console.log('\nServices that would use this EventBus:');
  console.log('  - JsAuthManager(eventBus, httpClient, secureStore)');
  console.log('  - JsSyncService(eventBus, library, httpClient)');
  console.log('  - JsPlaybackEngine(eventBus, audioContext)');
  console.log('  - JsLibrary(eventBus, database)');
  
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STEP 3: Create multiple subscribers (each gets ALL events)
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  
  // Subscriber 1: Main UI updates
  const uiReceiver = eventBus.subscribe();
  console.log('\nâœ“ UI subscriber created');
  
  // Subscriber 2: Analytics/logging
  const analyticsReceiver = eventBus.subscribe();
  console.log('âœ“ Analytics subscriber created');
  
  // Subscriber 3: Debug console
  const debugReceiver = eventBus.subscribe();
  console.log('âœ“ Debug subscriber created');
  
  console.log(`\nğŸ“Š Active subscribers: ${eventBus.subscriberCount()}`);
  
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STEP 4: Start event loops for each subscriber
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  
  let eventsProcessed = 0;
  const maxEvents = 5; // Process a few events for demo
  
  // UI Event Loop (updates user interface)
  const uiLoop = (async () => {
    console.log('\n[UI Loop] Started');
    while (eventsProcessed < maxEvents) {
      try {
        const eventJson = await uiReceiver.recv();
        const event: CoreEvent = JSON.parse(eventJson);
        
        console.log(`[UI] ğŸ–¥ï¸  ${event.type}.${event.payload.event}`);
        
        // Example: Update UI based on event
        switch (event.type) {
          case 'Auth':
            if (event.payload.event === 'SignedIn') {
              console.log(`[UI]    â†’ Show user profile: ${event.payload.profile_id}`);
            }
            break;
          case 'Sync':
            if (event.payload.event === 'Progress') {
              console.log(`[UI]    â†’ Update progress bar: ${event.payload.percent}%`);
            }
            break;
          case 'Library':
            if (event.payload.event === 'TrackAdded') {
              console.log(`[UI]    â†’ Refresh track list`);
            }
            break;
          case 'Playback':
            if (event.payload.event === 'Started') {
              console.log(`[UI]    â†’ Update now playing: ${event.payload.title}`);
            }
            break;
        }
      } catch (error) {
        if (String(error).includes('Lagged')) {
          console.warn('[UI] âš ï¸  Lagged behind, some events missed');
        } else if (String(error).includes('Closed')) {
          console.log('[UI] ğŸ›‘ EventBus closed');
          break;
        }
      }
    }
    console.log('[UI Loop] Stopped');
  })();
  
  // Analytics Event Loop (tracks metrics)
  const analyticsLoop = (async () => {
    console.log('[Analytics Loop] Started');
    while (eventsProcessed < maxEvents) {
      try {
        const eventJson = await analyticsReceiver.recv();
        const event: CoreEvent = JSON.parse(eventJson);
        
        console.log(`[Analytics] ğŸ“Š ${event.type}.${event.payload.event}`);
        
        // Example: Send to analytics service
        // await sendToAnalytics({
        //   eventType: `${event.type}.${event.payload.event}`,
        //   timestamp: Date.now(),
        //   ...event.payload
        // });
      } catch (error) {
        if (String(error).includes('Closed')) {
          break;
        }
      }
    }
    console.log('[Analytics Loop] Stopped');
  })();
  
  // Debug Event Loop (logs everything)
  const debugLoop = (async () => {
    console.log('[Debug Loop] Started');
    while (eventsProcessed < maxEvents) {
      try {
        const eventJson = await debugReceiver.recv();
        const event: CoreEvent = JSON.parse(eventJson);
        
        console.log(`[Debug] ğŸ” ${JSON.stringify(event, null, 2).substring(0, 100)}...`);
        eventsProcessed++; // Count here since debug sees all
      } catch (error) {
        if (String(error).includes('Closed')) {
          break;
        }
      }
    }
    console.log('[Debug Loop] Stopped');
  })();
  
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STEP 5: Simulate services publishing events
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  
  console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Simulating events from different services...');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
  
  await new Promise(resolve => setTimeout(resolve, 100)); // Let loops start
  
  // Event 1: Auth service publishes SignedIn
  console.log('ğŸ“¤ [AuthManager] Publishing Auth.SignedIn...');
  eventBus.emit(createAuthSignedInEvent('user-abc-123', 'GoogleDrive'));
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Event 2: Sync service publishes Started
  console.log('ğŸ“¤ [SyncService] Publishing Sync.Started...');
  eventBus.emit(createSyncStartedEvent('job-001', 'user-abc-123', 'GoogleDrive', true));
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Event 3: Sync service publishes Progress
  console.log('ğŸ“¤ [SyncService] Publishing Sync.Progress...');
  eventBus.emit(createSyncProgressEvent('job-001', BigInt(150), BigInt(300), 50, 'scanning'));
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Event 4: Library service publishes TrackAdded
  console.log('ğŸ“¤ [Library] Publishing Library.TrackAdded...');
  eventBus.emit(createLibraryTrackAddedEvent('track-001', 'Bohemian Rhapsody', 'Queen', 'A Night at the Opera'));
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Event 5: Playback service publishes Started
  console.log('ğŸ“¤ [Playback] Publishing Playback.Started...');
  eventBus.emit(createPlaybackStartedEvent('track-001', 'Bohemian Rhapsody'));
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Wait for all events to be processed
  await Promise.all([uiLoop, analyticsLoop, debugLoop]);
  
  console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('âœ… All subscribers received ALL events from ALL services!');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
  
  console.log('Key takeaways:');
  console.log('  âœ“ ONE EventBus shared by all services');
  console.log('  âœ“ Each subscriber gets independent copy of every event');
  console.log('  âœ“ await receiver.recv() uses async/await (no CPU spinning!)');
  console.log('  âœ“ Cross-module coordination without tight coupling');
  console.log('  âœ“ Inner type: VecDeque<T> circular buffer with Waker notifications');
}

// ============================================================================
// Run All Examples
// ============================================================================

async function main() {
  try {
    await initializeWasm();
    setupLogging();
    await demonstrateTypeSafeEvents();
    await demonstratePassingToRust();
    demonstrateFeatureFlags();
    demonstrateMetadataConfig();
    await demonstrateEventFiltering();
    await completeExample();
    await demonstrateSharedEventBus(); // â† NEW: Show ONE bus architecture
    
    console.log('\nğŸ‰ All examples completed successfully!');
  } catch (e) {
    console.error('Error:', e);
  }
}

// Run if this is the main module
if (typeof window !== 'undefined') {
  main();
}

// ============================================================================
// Exports (for use in other modules)
// ============================================================================

// Note: Classes are already exported at declaration, just re-export for clarity
// export { TypeSafeEventBus, TypeSafeEventReceiver };
